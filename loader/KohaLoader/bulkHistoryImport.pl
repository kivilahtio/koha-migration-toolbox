#!/usr/bin/perl

use Modern::Perl;
#use diagnostics;
BEGIN {
    # find Koha's Perl modules
    # test carefully before changing this
    use FindBin;
    eval { require "$FindBin::Bin/../kohalib.pl" };
    eval { use lib $FindBin::Bin; };
}

use open qw( :std :encoding(UTF-8) );
binmode( STDOUT, ":encoding(UTF-8)" );

use Getopt::Long;
use C4::Items;
use C4::Members;
use C4::Biblio;

use Bulk::ConversionTable::BorrowernumberConversionTable;
use Bulk::ConversionTable::ItemnumberConversionTable;

use Bulk::Util;

my $input_file = ($ENV{MMT_DATA_SOURCE_DIR}//'.').'/Statistics.migrateme';
my ($number, $offset, $help) = (0,0,undef);
my $borrowernumberConversionTable = ($ENV{MMT_WORKING_DIR}//'.').'/borrowernumberConversionTable';
my $itemnumberConversionTable = ($ENV{MMT_WORKING_DIR}//'.').'/itemnumberConversionTable';

$|=1;

GetOptions(
    'f|file:s'     => \$input_file,
    'b|bnConversionTable:s'                => \$borrowernumberConversionTable,
    'i|inConversionTable:s'                => \$itemnumberConversionTable,
    'h|help'     => \$help,
);

my $usage = << 'ENDUSAGE';

This script migrates History records from PallasPro.
The History-records need to be created by the Master Migration Tool's HistoryImportChain.

This script has the following parameters :
    -h --help  : this message
    -f --file  : The lillnhis.kir-file to import.

  --bnConversionTable  From which key-value -file to read the converted borrowernumber.
                       We are adding Patrons to a database with existing Patrons, so we need to convert
                       borrowernumbers so they won't overlap with existing ones.
                       borrowernumberConversionTable has the following format, where first column is the original
                       customer id and the second column is the mapped Koha borrowernumber:

                           1001003 12001003
                           1001004 12001004
                           1001006 12001005
                           1001007 12001006
                           ...

  --inConversionTable  From which file to read the conversion between itemnumber and Item's barcode.
                       File is generated by the bulkItemImport.pl and has the following content:

                           itemnumber:newItemnumber:barcode
                           10001000:1:541N00010001
                           10001001:2:541N00010013
                           10001074:3:541N00010746
                           ...

                       Defaults to 'itemnumberConversionTable'.


This script produces the following kind of errors:

THIS HISTORY HAS NOT BEEN CHECKED-IN FOR: (SKIPPING)
Eli tämä historiatieto oli Pallaksen konversion ajalta lainassa, muttei palautettuna. Nämä ovat siirtyneet kun lainoja vietiin.
Nämä historiatiedot jäävät Kohasta pois.

NO   BIBLIO   IN KOHA FOR:
Pallaksen luettelointitietueen tietokanta_id:tä (docid) ei löydy Kohasta. Varmaankin poistettu tietue.
Joillakin tietueilla, joista puuttu biblio, niin kuintekin löytyy ihan normaalisti tuo nide tuolla nidenumerolla. Tämä on tosi outoa. Uuden niteen biblionumber on sitten eri kuin historiatiedossa ollut.

NO  BORROWER  IN KOHA FOR: NO    ITEM    IN KOHA FOR: (SKIPPING)
Pallaksen asiakastietueen tietokanta_id:tä (custid) ei löydy Kohasta. Varmaankin poistettu tietue.
Nämä historiatiedot jäävät pois Kohasta.

NO    ITEM    IN KOHA FOR: (SKIPPING)
Pallaksen nidetietueen tietokanta_id:tä (copyid) ei löydy Kohasta. Varmaankin poistettu tietue.
Nämä historiatiedot jäävät pois Kohasta.

ENDUSAGE

if ($help || not($input_file)) {
    print $usage;
    exit;
}


my $fh = IO::File->new( $input_file, "<:encoding(utf-8)" );


$borrowernumberConversionTable = Bulk::ConversionTable::BorrowernumberConversionTable->new($borrowernumberConversionTable, 'read');
$itemnumberConversionTable = Bulk::ConversionTable::ItemnumberConversionTable->new( $itemnumberConversionTable, 'read' );


my $dbh = C4::Context->dbh;
my $old_issuesStatement =
      $dbh->prepare(
            "INSERT INTO old_issues
                (
                    issue_id,
                    borrowernumber,
                    itemnumber,
                    issuedate,
                    returndate,
                    branchcode,
                    date_due
                )
            VALUES (?,?,?,?,?,?,?)"
      );
my $statisticsStatement =
#COLUMN USAGE EXPLANATIONS
#            "INSERT INTO statistics
#                (
#                    `datetime`, --when the circulation event hapened
#                    `branch`,   --borrowers homebranch
#                    `proccode`, varchar(4) DEFAULT NULL, --not needed, set undef
#                    `value` double(16,4) DEFAULT NULL, --for some reason is set to 0.0000
#                    `type` varchar(16) DEFAULT NULL, --return or issue
#                    `other` mediumtext, -- set as ''
#                    `usercode` varchar(10) DEFAULT NULL, --when returning -> set to NULL, issues -> borrower.category
#                    `itemnumber` int(11) DEFAULT NULL,
#                    `itemtype` varchar(10) DEFAULT NULL, --when returning -> set to NULL, issues -> item.itype
#                    `borrowernumber` int(11) DEFAULT NULL, --when returning -> set to NULL, issues -> borrower.borrowernumber
#                    `associatedborrower` int(11) DEFAULT NULL, --NULL
#                    `ccode` varchar(10) DEFAULT NULL, --NULL
#                )
#            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)"
      $dbh->prepare(
            "INSERT INTO statistics
                (
                    `datetime`,
                    `branch`,
                    `proccode`,
                    `value`,
                    `type`,
                    `other`,
                    `usercode`,
                    `itemnumber`,
                    `itemtype`,
                    `borrowernumber`,
                    `associatedborrower`,
                    `ccode`
                )
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?)"
      );


## Get the id from where we start adding old issues. It is the biggest issue_id in use. It is important the issue_ids don't overlap.
$old_issue_id = Bulk::Util::getMaxIssueId($dbh);




sub migrate_history {
    my ( $history, $row ) = @_;
    my ($item, $borrower);

    my $itemnumber = $itemnumberConversionTable->fetch(  $history->{itemnumber}  ) if $history->{itemnumber};
    if ($itemnumber) {
        $item = C4::Items::GetItem($itemnumber);
    }

    my $borrowernumber = $borrowernumberConversionTable->fetch( $history->{borrowernumber} ) if $history->{borrowernumber};
    if ($borrowernumber) {
        $borrower = C4::Members::GetMember(borrowernumber => $borrowernumber);
    }


    if ($history->{type} eq 'return' && $borrowernumber && $itemnumber) {
        $old_issuesStatement->execute(
            $old_issue_id++,
            $borrowernumber,
            $itemnumber,
            $history->{datetime},
            $history->{datetime},
            $history->{branch},
            $history->{datetime},
        );
    }

    $statisticsStatement->execute(
        $history->{datetime},
        $history->{branch},
        undef,
        0.0000,
        $history->{type},
        undef,
        ($borrower ? $borrower->{categorycode} : undef),
        $itemnumber,
        ($item ? $item->{itype} : undef),
        $borrowernumber,
        undef,
        undef,
    );
}


my $i = 0;
while (<$fh>) {
    $i++;
    print ".";
    print "\n$i" unless $i % 100;

    my $history = Bulk::Util::newFromBlessedMigratemeRow($_);

    migrate_history($history, $_);

    last if $i == $number;
}


